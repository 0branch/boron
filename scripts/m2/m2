#!/usr/bin/boron
/*
	M2 - A meta-make tool
	Copyright 2001-2010 Karl Robillard
	Version 1.0.2

	TODO:
		* Remove files outside the build directory from dist rule.
		* Add Qt moc files to sources but not to distribution rule.

	These words are defined in the template file:
		generate_makefile

		exe_target
		lib_target
		shlib_target

		makerule_cxx
		makerule_asm
		makerule_c

	NOTE: Symbolic links don't work!
*/


project_file: "project.b"
template_file: 
	;"/usr/share/boron/m2/m2_template.b"
	"/home/karl/src/urlan/boron/scripts/m2/m2_linux.b"
debug_include: false


m2: context
[
	;--------------------------------------
	; These are constant for each makefile.

	makefile: "Makefile"
	default_block: none

	; Returns string with name and version
	project_version: does [
		replace/all either version
			[rejoin [project '-' version]]
			[copy project]
				' ' '_'
	]

	ct: none
	targets: []
	output_buf: make string! 2048

	; This contains file! block! pairs.  The block contains the files
	; included in the file.
	include_dict: []

	distribution_files: []


	;--------------------------------------
	; These can be changed for each target.

	configuration: context [
		release: debug: warn:
		opengl: qt: qt-static: x11: false
	]

	target_env: context [
		name: none
		uc_name: none
		output_file: none
		link_cxx: false

		objdir: none
		output_dir: "" 
		obj_ext: ".o"
		cxx_ext: ".cpp"
		defines: []

		include_paths: []
		link_paths: []
		link_libs: []

		header_files: []
		source_files: []
		object_files: []
		custom_flags: []	; Pairs of file & flags.

		moc_files: []
		srcmoc_files: []

		menv_aflags: {}
		menv_cflags: {}
		menv_cxxflags: {}
		menv_lflags: {}

		cfg: none
	
		configure:
		macro_text:
		rule_text: none

		custom_src: func [src | flags] [
			either flags: select custom_flags src
				[rejoin [src ' ' flags]]
				[src]
		]

		rule_makeobj: func [cc flags obj src] [
			; Default to GNU
			rejoin ["^-$(" cc ") -c $(" uc_name flags ") -o " obj 
					" $(" uc_name "_INCPATH) " custom_src src]
		]
		makerule_cxx: func [obj src] [link_cxx: true
									   rule_makeobj "CXX" "_CXXFLAGS" obj src]
		makerule_c:   func [obj src] [rule_makeobj "CC" "_CFLAGS" obj src]
		makerule_asm: func [obj src] [
			; Default to GNU
			rejoin ["^-$(AS) $(" uc_name "_AFLAGS) -o " obj 
					" $(" uc_name "_INCPATH) " custom_src src]
		]

		file_rules: [
			".cpp" makerule_cxx
			".cxx" makerule_cxx
			".cc"  makerule_cxx
			".c"   makerule_c	 ; Must follow c++ entries.
			".s"   makerule_asm
			".asm" makerule_asm
		]

		make_obj_rule: func [
			/* Builds rules which make object files.
			   Dependencies are automatically generated by recursively
			   searching in sources and included files.
			   Called from the template. */
			| str src obj srcfile dependencies inc common ext rfunc
		][
			str: make string! 512
			src: source_files
			foreach obj object_files [
				append str rejoin [obj ": " src/1]

				srcfile: to-file src/1

				either exists? srcfile [
					dependencies: select include_dict srcfile
				][
					print ["make_obj_rule: Warning -" srcfile "not found"]
					dependencies: []
				]

				either dependencies [
					either empty? dependencies [
						append str '^/'
					][
						append str " \^/"
						foreach dep dependencies [
							inc: select include_dict dep
							ifn inc [
							  append_include_dict dependencies include_paths
							  inc: select include_dict dep
							]
							common: intersect dependencies inc
							append dependencies difference inc common
						]
						append str expand_list_gnu sort dependencies
					]
				][
					append str '^/'
				]

				; Explicitly state rule
				foreach [ext rfunc] file_rules [
					;print [ext get rfunc]
					if find src/1 ext [
						append str join do rfunc obj src/1 "^/^/"
						break
					]
				]

				++ src

				append header_files dependencies
			]

			header_files: sort intersect header_files header_files
			str
		]

		moc_rule: func [| str src file] [
			str: make string! 0
			src: srcmoc_files
			foreach file moc_files [
				append str rejoin [
					first src ": " file
					"^/^-$(MOC) " file " -o " first src "^/^/"
				]
				++ src
			]
			str
		]
	]

	;--------------------------------------

	static_lib_targets: []

	local_libs: func [
		; Returns string of libraries from libs which are built by this
		; project file.
		libs
		| l str base path
	][
		str: make string! 0
		foreach [base path] static_lib_targets [
			if l: find libs base [
				append str rejoin [' ' path]
				;probe first l
			]
		]
		str
	]


	header_files_used: func [
		; Returns a block containing all header files used in the project.
		| blk f b
	][
		blk: copy [] 
		foreach [f b] include_dict [
			append blk b
		]
		sort intersect blk blk
	]


	append_include_dict: func [
		; Returns a block all files included from files
		files paths | headers blk f
	][
		headers: copy []

		; Should make include_dict a hash?
		foreach f files [
			ifn select include_dict f [
				blk: included_files f paths
				append headers blk

				append include_dict f
				append/block include_dict blk
			]
		]
		sort intersect headers headers
	]

	add_target: func [target blk] [
		ct: target
		append targets ct

		do default_block
		do blk

		either ct/objdir [
			ifn exists? ct/objdir [
				make-dir ct/objdir
			]
		][
			ct/objdir: ""
		]

		ct/configure
		ct/object_files: make_file_list ct/source_files ct/objdir ct/obj_ext

		ct/header_files: append_include_dict ct/source_files ct/include_paths
		;probe include_dict
		;probe ct/header_files

		if ct/cfg/qt [
			add_moc_files ct ct/header_files

			; Uncomment this to search cpp files for Q_OBJECT.
			;add_moc_files source_files

			append ct/object_files
				make_file_list ct/srcmoc_files ct/objdir ct/obj_ext

			append ct/source_files ct/srcmoc_files
		]
	]

	set 'build_makefile func [projfile template] [
		do bind load template 'emit
		do bind load projfile 'emit
		clear output_buf
		write makefile generate_makefile
	]

	;------------------------------------------------------------------
	; Used in template file.

	eol: '^/' 
	emit: func [data] [append output_buf reduce data]

	dist_files: func [| str obj] [
		str: make string! 64

		obj: copy []
		foreach t targets [append obj t/objdir]
		obj: intersect obj obj   ; Removes duplicates.
		append str obj

		foreach t targets [append str t/dist]
		str
	]

	;------------------------------------------------------------------
	; Used in project file.

	project: "project"
	version: none

	linux:
	macx:
	sun:
	unix:
	win32:
	system-nop: func [blk block!] []  ; skip block by default

	default:	func [blk] [default_block: blk]
	objdir:		func [dir] [ct/objdir: dir]
	into:		func [dir] [ct/output_dir: term-dir dir]

	aflags:		func [str string!] [add_flags ct/menv_aflags   str]
	cflags:		func [str string!] [add_flags ct/menv_cflags   str]
	cxxflags:	func [str string!] [add_flags ct/menv_cxxflags str]
	lflags:		func [str string!] [add_flags ct/menv_lflags   str]

	debug:		does [ct/cfg/debug:   true] ; Building debug version.
	release:	does [ct/cfg/release: true] ; Optimize for release build.
	warn:		does [ct/cfg/warn:    true] ; Enable compiler warnings.

	opengl:		does [ct/cfg/opengl: true]  ; Using OpenGL libraries.
	qt:			func [libs block!] [ct/cfg/qt: libs]  ; Using Qt 4.
	qt-static:	does [ct/cfg/qt-static: true]
	x11:		does [ct/cfg/x11: true]     ; Using X11 libraries.

	define:		func [str string!] [append ct/defines parse-white str]

	include_from: func [list string!/file!/block!] [
		if string? list [
			list: parse-white list
		]
		; TODO: Run conv_slash on each item.
		append ct/include_paths reduce list
	]

	libs: func [list string!/file!/block!] [
		if string? list [
			list: parse-white list
		]
		append ct/link_libs list
	]

	libs_from: func [dir list] [
		append ct/link_paths dir
		libs list
	]

	dist: func [arg block!] [
		append distribution_files arg
	]

	sources: func [arg block! /flags fstr] [
		append ct/source_files arg
		if flags [
			forall arg [
				append ct/custom_flags first arg
				append ct/custom_flags fstr
			]
		]
	]

	sources_from: func [path files block!] [
		; include_from path
		term-dir path
		forall files [
			append ct/source_files join path first files
		]
	]

	var-name: func [name] [
		; NMake does not allow '-' in variable names.
		replace/all uppercase copy name '-' '_'
	]

	exe: func [{Builds executable rule.} basename blk]
	[
		add_target (make exe_target [
				uc_name: var-name name: basename
				cfg: copy configuration
			]) blk
	]

	lib: func [{Builds static library rule.} basename blk]
	[
		add_target (make lib_target [
				uc_name: join "LIB_" var-name name: basename
				cfg: copy configuration
			]) blk

		append static_lib_targets reduce [basename ct/output_file]
	]

	shlib: func [{Builds shared library rule.} basename blk]
	[
		add_target (make shlib_target [
				uc_name: join "SLIB_" var-name name: basename
				cfg: copy configuration
			]) blk
	]

	; Builds generic make rule.
	rule: func [output dep commands] [
		append targets make target_env [
			uc_name: join "FILE_" var-name name: output_file: output
			cfg: copy configuration

			built_obj_rule: make_obj_rule: ""
			clean: rejoin [
				either same? :system-nop :win32 ["^--rm -f "]["^--@del "]
				output_file eol
			]
			dist: to-text dep
			; Trim twice to remove any newline from last command.
			rule_commands: replace/all trim trim/indent commands '^/' "^/^-"
			rule_text: does copy/deep [
				emit [eol output_file ": " dist {^/^-} rule_commands eol]
			]
		]
	]

	gnu_string: func [
		; Returns string of items each with a prefix.
		prefix string!
		items  block!
		| str
	][
		str: make string! 64
		forall items [
			append str either (find items/1 ' ') [
				rejoin [' ' prefix '"' items/1 '"']
			][
				rejoin [' ' prefix items/1]
			]
		]
		remove str
	]


	;------------------------------------------------------------------
	; Private Helpers


read-buf: func [file] [read/into file clear ""]

white: charset " ^-^/"
non-white: complement copy white
parse-white: func [str string! | blk tok] [
	blk: make block! 8
	parse str [any[
		any white tok: some non-white :tok (append blk tok)
	]]
	if empty? blk [append blk str]
	blk
]

add_flags: func [flags str] [
	append flags
		either empty? flags
			[trim/lines str]
			[join ' ' trim/lines str]
]

strip_ext: func [file] [		; Modifies file
	clear find/last file '.'
	file
]


make_file_list: func [
	; Copy a block of files with changed path and extension
	src  block!
	dir
	extension
	| obj file
][
	obj: copy/deep src
	either empty? dir [
		forall obj [
			strip_ext obj/1
			append obj/1 extension
		]
	][
		forall obj [
			file: second split-path obj/1
			obj/1: rejoin [term-dir dir strip_ext file extension]
		]
	]
	head obj
]


idprint: func [blk] pick [[print blk] []] debug_include

find_include_file: func [
	; Checks if a file exists in the current directory or any set of paths.
	file  file!/string!
	paths block!
	| path full
][
	idprint [' ' file]
	if exists? file [return file]

	forall paths [
		path: to-file paths/1
		term-dir path
		full: join path file

		idprint ["   " full]
		if exists? full [return full]
	]
	none
]


space: charset { ^-}

included_files: func [
   /* Returns a block of the files which are included in a C/C++ file.
	  Addes   #include "file.h"
	  Ignores #include <file.h>
	  Ignores #include MACRO */
	file  file!/string! "File to check for #include statements"
	paths block!        "Paths to check for included files"
	| blk tmp
][
	blk: make block! 8

	ifn exists? file [
		print ["included_files:" file "not found"]
		return blk
	]

	; BUG: #include can be defined out but will still be included here.
	; This causes errors when Windows-only code includes files with paths
	; (using backslash) and we are compiling on a non-Windows system.

	parse read-buf file [
		any [
			thru "^/#include" some space [
				'"' tmp: to '"' :tmp (append blk copy tmp)
				| to '^/'
			]
		]
	]

	blk: intersect blk blk   ; Removes duplicates.

	if debug_include [print ["Finding include files for" file] probe blk]

	forall blk [
		tmp: find_include_file blk/1 paths
		either tmp [
			blk/1: tmp
		][
			print rejoin
				["included_files: " blk/1 " (from " file ") not found!"]
			remove blk
			blk: prev blk
		]
	]
	head blk
]


/*
  Replace each tag in a string with the value of the tag.
  Individual '<' and '>' are allowed, but they cannot be used
  between other < > pairs.
*/
do_tags: func [str string! | exp]
[
	; TODO: Handle individual </>.
	parse str [
		any [
			to '<' exp: thru '>' :exp
			(exp: change/slice exp  do slice exp 1,-1)
			place exp
		]
	]
	str
]


; Nothing by default.
conv_slash: func [file] [file]


expand_list_gnu: func [
	; Returns a string with each file on a seperate line.
	files  block!
	/part    ; Do not erase trailing space and slash
	| str
][
	str: make string! 64
	forall files [
		append str rejoin ['^-' conv_slash first files { \^/}]
	]
	ifn part [
		remove/part find/last str ' ' 2
	]
	str
]


add_moc_files: func [ct files block! | blk dir file]
[
	blk: make block! 0
	foreach file files [
		if find/case read-buf file "Q_OBJECT" [
			append ct/moc_files file

			set [dir file] split-path file

			; MOC bug - specifying "./" on output file creates bad include
			; statements.
			; if equal? dir "./" [dir: ""]
			ifn dir [dir: ""]

			append ct/srcmoc_files join dir
				["moc_" strip_ext copy file ct/cxx_ext]
		]
	]
	blk
]

]


;------------------------------------------------------------------
; Read command line arguments and invoke build_makefile.


if args [
	forall args [
		switch first args [
			"-t" [template_file: second ++ args]
			"-o" [m2/makefile:   second ++ args]
			[project_file: first args]
		]
	]
]

;print [project_file template_file m2/makefile]

ifn exists? template_file [
	print [
		"Template" template_file
		"not found.^/Use the -t option or edit template_file in the m2 script."
	]
	quit
]

either exists? project_file [
	build_makefile project_file template_file
][
	print [project_file "does not exist; Please specify project file."]
]

;probe m2/header_files_used
quit


;EOF
